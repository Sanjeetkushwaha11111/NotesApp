package com.sanjeet.androidassignment.practice.oop//Sealed classes in Kotlin provide a robust way to define restricted class hierarchies,// improving type safety and maintainability.// By ensuring all subclasses are known at compile-time,// sealed classes facilitate exhaustive when expressions and controlled inheritance//I see only one reasoning of sealed class.// It's compilation performance.// With sealed modifier the compiler already knows that no more subclasses exist,// while without it the compiler can process when expressions only after all source files are handled,sealed class NetworkResult<T>(    val data: T? = null, val message: String? = null) {    class Success<T>(data: T) : NetworkResult<T>(data)    class Error<T>(message: String?, data: T? = null) : NetworkResult<T>(data, message)    class Loading<T> : NetworkResult<T>()}fun main() {    when (val result = fetchUserData()) {        is NetworkResult.Success -> {            println("Success: ${result.data}")        }        is NetworkResult.Error -> {            println("Error: ${result.message}")        }        is NetworkResult.Loading -> {            println("Loading...")        }    }}fun fetchUserData(): NetworkResult<String> {    return when ((1..2).random()) {        1 -> NetworkResult.Success("User data successfully fetched")        2 -> NetworkResult.Error("Failed to fetch user data")        else -> NetworkResult.Loading()    }}