package com.sanjeet.androidassignment.practice.desingpattern/**      SOLID PrincipleSingle Responsibility Principle:  It says a class should possess only one responsibility or a jobOpen/Closed Principle : It says classes, modules, functions, and other software entities should be open for extension but closed for modificationLiskov Substitution Principle: All the methods and properties in the main class should also work for all the sub-classes without needing to change anything.Interface Segregation Principle: It says that when we make different parts of a program, we shouldn’t make them all the same way.Instead, we should make them smaller and more specific, so that other parts of the program don’t haveto depend on things they don’t need. This helps us make code that’s easier to change and take care of,because each part only does what it needs to do.Dependency Inversion Principle: That states that high-level modules should not depend on low-level modules,but both should depend on abstractions. This means that classes should depend on abstractions,not on concrete implementations. The idea behind DIP is to decouple components from each other,which makes the code more modular, easier to test, and more maintainable. *///--------------------------------Single Responsibility Principle---------------------------//Violationclass SystemManager {    fun addUser(user: String) {}    fun deleteUser(user: String) {}    fun sendNotification(notification: String) {}    fun sendEmail(user: String, email: String) {}}//correct usageclass MailManager() {    fun sendEmail(user: String, email: String) {}}class NotificationManager() {    fun sendNotification(notification: String) {}}class UserManager {    fun addUser(user: String) {}    fun deleteUser(user: String) {}}//-----------------------------Open/Closed Principle----------------------------------------------//Violation// In this example, when we try to add something new to our class,// we have to rewrite our existing code, which can cause problems later on.class Shape1(val type: String, val width: Double, val height: Double)fun calculateArea1(shape: Shape1): Double {    if (shape.type == "rectangle") {        return shape.width * shape.height    } else if (shape.type == "circle") {        return Math.PI * shape.width * shape.width    }    return 0.0}//correct usage// As in correct usage, instead of changing the class itself,// we wrote new classes using our existing class// and implemented our functions under new classes.interface Shape {    fun area(): Double}class Rectangle(val width: Double, val height: Double) : Shape {    override fun area() = width * height}class Circle(val radius: Double) : Shape {    override fun area() = Math.PI * radius * radius}fun calculateArea(shape: Shape) = shape.area()//--------------------------------Liskov Substitution Principle---------------------------//Violation// As we saw in this example, the method we wrote in our main class should work properly in its subclasses according to the Liskov principle,// but when our subclass inherited from our superclass, our fly method did not work as expected.open class Bird1 {    open fun fly() {}}class Penguin1 : Bird1() {    override fun fly() {        print("Penguins can't fly!")    }}//Correct Usage// As you can see in this example, all the things we write in the superclass will be valid in the subclasses,// because we have implemented the method that is not valid for subclasses by creating an interface and implementing it where we need it.open class Bird {    // common bird methods and properties}interface IFlyingBird {    fun fly(): Boolean}class Penguin : Bird() {    // methods and properties specific to penguins}class Eagle : Bird(), IFlyingBird {    override fun fly(): Boolean {        return true    }}//--------------------------------Interface Segregation Principle---------------------------// Violation// When we look at our example, we see that the interface we created contains many methods.// If we do everything inside a common interface, we may have made unnecessary use in the places that implement our interface.// Instead, we can divide our system into smaller interface parts.interface Animal {    fun swim()    fun fly()}class Duck : Animal {    override fun swim() {        println("Duck swimming")    }    override fun fly() {        println("Duck flying")    }}class Penguin2 : Animal {    override fun swim() {        println("Penguin swimming")    }    override fun fly() {        throw UnsupportedOperationException("Penguin cannot fly")    }}// Interface Segregation Principle Correct Usage// As we saw in the correct usage example, dividing the system into smaller interfaces and using them where we needed them made it much easier to change the system in the future.interface CanSwim {    fun swim()}interface CanFly {    fun fly()}class Duck1 : CanSwim, CanFly {    override fun swim() {        println("Duck swimming")    }    override fun fly() {        println("Duck flying")    }}class Penguin3 : CanSwim {    override fun swim() {        println("Penguin swimming")    }}//--------------------------------Dependency Inversion Principle---------------------------// Dependency Inversion Principle Correct Usage// In the correct usage example, we did not have to implement hard code about our payment methods in our Service class,// because we set up an abstract structure with the interface that we created.interface PaymentProcessor {    fun processPayment(amount: Double): Boolean}class PaypalPaymentProcessor : PaymentProcessor {    override fun processPayment(amount: Double): Boolean {        // Process payment via Paypal API        return true    }}class StripePaymentProcessor : PaymentProcessor {    override fun processPayment(amount: Double): Boolean {        // Process payment via Stripe API        return true    }}class PaymentService(private val paymentProcessor: PaymentProcessor) {    fun processPayment(amount: Double): Boolean {        return paymentProcessor.processPayment(amount)    }}fun main() {    val paymentProcessor = PaypalPaymentProcessor()    val paymentService = PaymentService(paymentProcessor)    println(paymentService.processPayment(50.0)) // Process payment via Paypal API}