package com.sanjeet.androidassignment.ui.characterlistimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.ViewGroupimport android.widget.Toastimport androidx.recyclerview.widget.DiffUtil.ItemCallbackimport androidx.recyclerview.widget.ListAdapterimport androidx.recyclerview.widget.RecyclerViewimport com.bumptech.glide.Glideimport com.bumptech.glide.load.resource.drawable.DrawableTransitionOptionsimport com.sanjeet.androidassignment.Rimport com.sanjeet.androidassignment.data.characterModel.Characterimport com.sanjeet.androidassignment.databinding.CharacterListItemBindingimport com.sanjeet.androidassignment.ui.characterlist.CharacterListAdapter.Companion.BUNDLE_BOOKMARKimport com.sanjeet.androidassignment.ui.characterlist.CharacterListAdapter.Companion.BUNDLE_SUBNAMEimport timber.log.Timberclass CharacterListAdapter(    private var viewModel: CharacterViewModel) : ListAdapter<Character, CharacterListViewHolder>(DiffCallback) {    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CharacterListViewHolder {        return CharacterListViewHolder(            CharacterListItemBinding.inflate(                LayoutInflater.from(parent.context), parent, false            ), viewModel        ) { position ->            notifyItemChanged(position)        }    }    override fun onBindViewHolder(holder: CharacterListViewHolder, position: Int) {        holder.bindItems(getItem(position))    }    override fun onBindViewHolder(        holder: CharacterListViewHolder,        position: Int,        payloads: MutableList<Any>    ) {        if (payloads.isEmpty()) {            super.onBindViewHolder(holder, position, payloads)        } else {            val diffBundle: Bundle = payloads[0] as Bundle            holder.updateState(diffBundle, position)        }    }    override fun setHasStableIds(hasStableIds: Boolean) {        super.setHasStableIds(true)    }    override fun getItemId(position: Int): Long {        return position.toLong()    }    override fun getItemViewType(position: Int): Int {        return position    }    object DiffCallback : ItemCallback<Character>() {        override fun areItemsTheSame(oldItem: Character, newItem: Character): Boolean {            return oldItem.episodeName == newItem.episodeName        }        override fun areContentsTheSame(ldItem: Character, newItem: Character): Boolean {            return false        }        override fun getChangePayload(oldItem: Character, newItem: Character): Any {            val diffBundle = Bundle()            diffBundle.putString(BUNDLE_SUBNAME, newItem.episodeName)            diffBundle.putBoolean(BUNDLE_BOOKMARK, newItem.isBookMarked)            return diffBundle        }    }    companion object {        const val BUNDLE_SUBNAME = "bundle_subname"        const val BUNDLE_BOOKMARK = "bundle_bookmark"    }}class CharacterListViewHolder(    private var binding: CharacterListItemBinding,    private var viewModel: CharacterViewModel,    private val notifyItemChangedCallback: (Int) -> Unit) : RecyclerView.ViewHolder(binding.root) {    fun bindItems(itemChar: Character) {        Glide.with(binding.image.context).load(itemChar.image)            .transition(DrawableTransitionOptions.withCrossFade()).into(binding.image)        itemChar.apply {            binding.name.text = name            binding.allDetails.text = "${gender} . ${species} . ${location.name}"            if (episodeName.isNullOrEmpty()) {                binding.episodeName.text = "..."            } else {                binding.episodeName.text = episodeName            }        }        if (itemChar.isBookMarked) {            binding.bookmark.setImageResource(R.drawable.filled_star)        } else {            binding.bookmark.setImageResource(R.drawable.unfilled_star)        }        binding.bookmark.setOnClickListener {            viewModel.toggleBookmarkForCharacter(itemChar, !itemChar.isBookMarked)            itemChar.isBookMarked = !itemChar.isBookMarked            binding.bookmark.setImageResource(                if (itemChar.isBookMarked) R.drawable.filled_star else R.drawable.unfilled_star            )            notifyItemChangedCallback(bindingAdapterPosition)            Toast.makeText(                binding.name.context,                "${itemChar.name} ${if (itemChar.isBookMarked) "added to" else "removed from"} bookmark",                Toast.LENGTH_SHORT            ).show()        }    }    fun updateState(bundle: Bundle, position: Int) {        val episodeName = bundle.getString(BUNDLE_SUBNAME, "...")        val isBookmarked = bundle.getBoolean(BUNDLE_BOOKMARK, false)        Timber.e(">>>>>>>>into update state episodeName $episodeName")        Timber.e(">>>>>>>>into update state isBookmarked  $isBookmarked")        binding.episodeName.text = episodeName        if (isBookmarked) {            binding.bookmark.setImageResource(R.drawable.filled_star)        } else {            binding.bookmark.setImageResource(R.drawable.unfilled_star)        }    }}